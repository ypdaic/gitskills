下面是spring CglibAopProxy创建代理的代码

// Enhancer用于创建代理
Enhancer enhancer = createEnhancer();
if (classLoader != null) {
    enhancer.setClassLoader(classLoader);
    if (classLoader instanceof SmartClassLoader &&
            ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) {
        enhancer.setUseCache(false);
    }
}
// 设置代理对象的父类，也就是被代理对象
enhancer.setSuperclass(proxySuperClass);
// 设置代理对象的接口，也就被代理对象的接口·
enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));
// 设置代理类名称创建策略
enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
enhancer.setStrategy(new ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));

// 设置方法被代理时，实际要执行的回调
Callback[] callbacks = getCallbacks(rootClass);
Class<?>[] types = new Class<?>[callbacks.length];
for (int x = 0; x < types.length; x++) {
    types[x] = callbacks[x].getClass();
}
// fixedInterceptorMap only populated at this point, after getCallbacks call above
// 设置回调过滤器，也就在创建代理类时，为每个方法指定不同的callback 就是根据这个过滤器的返回值指定的
enhancer.setCallbackFilter(new ProxyCallbackFilter(
        this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset));
enhancer.setCallbackTypes(types);

// 创建代理类
// Generate the proxy class and create a proxy instance.
return createProxyClassAndInstance(enhancer, callbacks);