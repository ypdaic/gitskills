总接口：Executor
子接口：ScheduledExecutorService -> ExecutorService -> Executor
抽象实现：AbstractExecutorService -> ExecutorService （实现了invokeAll，invokeAny，submit 这些公共方法）
子类实现：ThreadPoolExecutor -> AbstractExecutorService | ForkJoinPool -> AbstractExecutorService
         ScheduledThreadPoolExecutor -> ScheduledExecutorService (延时任务，定时任务)

工具类：Executors 用于提供各种固定的线程池

       // 缓存线程池，核心程序池大小为0，最大任务数为Integer.MAX_VALUE，任务闲置时间60s，任务队列为无空间的SynchronousQueue
       // 对队列的读，写都需要等对队列的写和读
       // 这个线程的工作原理就是
       public static ExecutorService newCachedThreadPool() {
               return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                             60L, TimeUnit.SECONDS,
                                             new SynchronousQueue<Runnable>());
           }

       由于核心线程数是0，提交进来的任务，会存放到队列，又由于使用的是SynchronousQueue队列，put方法没法存放该任务，只能新创建一个work去执行该任务
       当这个任务执行完成后，该work会等待keepliveTime 时间，如果此时有新的任务进来，则该work会被唤醒拿到任务继续执行，然后又来了新任务，由于当前么有
       work在等待任务，则会开启新的work去执行该任务


       public static ExecutorService newSingleThreadExecutor() {
               return new FinalizableDelegatedExecutorService
                   (new ThreadPoolExecutor(1, 1,
                                           0L, TimeUnit.MILLISECONDS,
                                           new LinkedBlockingQueue<Runnable>()));
           }

       核心线程数，最大线程数都为1的线程池，队列大小为int的最大值

       public static ExecutorService newFixedThreadPool(int nThreads) {
               return new ThreadPoolExecutor(nThreads, nThreads,
                                             0L, TimeUnit.MILLISECONDS,
                                             new LinkedBlockingQueue<Runnable>());
           }


        核心线程数，最大线程数一样的线程池，队列大小为int最大值



       public static ExecutorService newWorkStealingPool() {
                return new ForkJoinPool
                    (Runtime.getRuntime().availableProcessors(),
                     ForkJoinPool.defaultForkJoinWorkerThreadFactory,
                     null, true);
            }

       工作窃取线程池，线程数为cpu核心数大小