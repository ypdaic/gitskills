
公平锁加锁过程：

    第一个线程加锁不会产生队列，因为直接就可以获取信息量了，就没必要产生队列
    第二个线程加锁，此时会产生队列，并且队列中包含一个空的头节点，和加锁线程对应的节点，然后加锁线程自旋一次，尝试加锁，如果信号量此时为0，则获取锁，并将自己设置为头节点
                   如果信号量为1，则直接park进行阻塞，并且设置前驱节点的waitStatus为SIGNAL，表示锁在释放时，直到有线程在等待获取锁
    第三个线程加锁，创建一个新的节点放到队尾，并判断自己的前驱节点是否为空节点，如果为空，则和第二个线程做同样的处理，如果不为空，则直接进行park等待

非公平锁加锁过程：

    final void lock() {
        // 直接设置state为1，如果不成功进行acquire，acquire会调用nonfairTryAcquire
        if (compareAndSetState(0, 1))
            setExclusiveOwnerThread(Thread.currentThread());
        else
            acquire(1);
    }

    // 当state为0时，再次设置state为1，如果在不成功，就走公平锁的第二个线程，第三个线程的过程
    // 非公平就是通过设置cas 设置state为1，成功就表示抢到了锁，而不去管你是否排队了，排队了后续还是根据排序顺序执行
    final boolean nonfairTryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc < 0) // overflow
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false;
    }