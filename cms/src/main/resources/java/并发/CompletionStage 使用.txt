1. 描述串行关系
    CompletionStage接口里面描述串行关系，主要是thenApply、thenAccept、thenRun和thenCompose这四 个系列的接口。

    thenApply系列函数里参数fn的类型是接口Function<T, R>，这个接口里与CompletionStage相关的方法是 R apply(T t)，这个方法既能接收参数也支持返回值，所以thenApply系列方法返回的 是CompletionStage<R>。

    而thenAccept系列方法里参数consumer的类型是接口Consumer<T>，这个接口里与CompletionStage相关 的方法是void accept(T t)，这个方法虽然支持参数，但却不支持回值，所以thenAccept系列方法返回 的是CompletionStage<Void>。

    thenRun系列方法里action的参数是Runnable，所以action既不能接收参数也不支持返回值，所以thenRun 系列方法返回的也是CompletionStage<Void>。

    这些方法里面Async代表的是异步执行fn、consumer或者action。其中，需要你注意的是thenCompose系列 方法，这个系列的方法会新创建出一个子流程，最终结果和thenApply系列是相同的。

      CompletionStage<R> thenApply(fn);
      CompletionStage<R> thenApplyAsync(fn);
      CompletionStage<Void> thenAccept(consumer);
      CompletionStage<Void> thenAcceptAsync(consumer);
      CompletionStage<Void> thenRun(action);
      CompletionStage<Void> thenRunAsync(action);
      CompletionStage<R> thenCompose(fn);
      CompletionStage<R> thenComposeAsync(fn);


2. 描述AND关系

    CompletionStage接口里面描述AND汇聚关系，主要是thenCombine、thenAcceptBoth和runAfterBoth系列
    的接口，这些接口的区别也是源自fn、consumer、action这三个核心参数不同。它们的使用你可以参考上 面烧水泡茶的实现程序，这里就不赘述了。

      CompletionStage<R> thenCombine(other, fn);
      CompletionStage<R> thenCombineAsync(other, fn);
      CompletionStage<Void> thenAcceptBoth(other, consumer);
      CompletionStage<Void> thenAcceptBothAsync(other, consumer);
      CompletionStage<Void> runAfterBoth(other, action);
      CompletionStage<Void> runAfterBothAsync(other, action);

3. 描述OR汇聚关系

    CompletionStage接口里面描述OR汇聚关系，主要是applyToEither、acceptEither和runAfterEither系列的 接口，这些接口的区别也是源自fn、consumer、action这三个核心参数不同。

        CompletionStage applyToEither(other, fn);
        CompletionStage applyToEitherAsync(other, fn);
        CompletionStage acceptEither(other, consumer);
        CompletionStage acceptEitherAsync(other, consumer);
        CompletionStage runAfterEither(other, action);
        CompletionStage runAfterEitherAsync(other, action);


4. 异常处理
    虽然上面我们提到的fn、consumer、action它们的核心方法都不允许抛出可检查异常，但是却无法限制它 们抛出运行时异常，例如下面的代码，执行 7/0 就会出现除零错误这个运行时异常。
    非异步编程里面，我 们可以使用try{}catch{}来捕获并处理异常，那在异步编程里面，异常该如何处理呢?

      CompletionStage exceptionally(fn);
      CompletionStage<R> whenComplete(consumer);
      CompletionStage<R> whenCompleteAsync(consumer);
      CompletionStage<R> handle(fn);
      CompletionStage<R> handleAsync(fn);

      下面的示例代码展示了如何使用exceptionally()方法来处理异常，exceptionally()的使用非常类似于 try{}catch{}中的catch{}，但是由于支持链式编程方式，
      所以相对更简单。既然有try{}catch{}，那就一定还 有try{}finally{}，
      whenComplete()和handle()系列方法就类似于try{}finally{}中的finally{}，无论是否发生异 常都会执行whenComplete()中的回调函数consumer和handle()中的回调函数fn。
      whenComplete()和 handle()的区别在于whenComplete()不支持返回结果，而handle()是支持返回结果的。