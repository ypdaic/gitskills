Synchronized与Lock都是提供锁的功能，从表现上Synchronized提供的是隐式锁，而Lock提供的显示锁，Synchronized阻塞后没有任何手段将其唤醒
而Lock接口提供了3种方式，在阻塞后，可以放弃锁的等待


1. 能够响应中断。synchronized 的问题是，持有锁 A 后，如果尝试获取锁 B 失败，那么线程就 进入阻塞状态，一旦发生死锁，就没有任何机会来唤醒阻塞的线程。但如果阻塞状态的线程能 够响应中断信号，也就是说当我们给阻塞的线程发送中断信号的时候，能够唤醒它，那它就有 机会释放曾经持有的锁 A。这样就破坏了不可抢占条件了。
2. 支持超时。如果线程在一段时间之内没有获取到锁，不是进入阻塞状态，而是返回一个错误， 那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。
3. 非阻塞地获取锁。如果尝试获取锁失败，并不进入阻塞状态，而是直接返回，那这个线程也有 机会释放曾经持有的锁。这样也能破坏不可抢占条件。

Lock接口提供的功能：

     // 支持中断的 API
    2 void lockInterruptibly()
    3 throws InterruptedException;
    4 // 支持超时的 API
    5 boolean tryLock(long time, TimeUnit unit)
    6 throws InterruptedException;
    7 // 支持非阻塞获取锁的 API
    8 boolean tryLock();