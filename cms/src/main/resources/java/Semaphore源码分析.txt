

FairSync 分析

 static final class FairSync extends Sync {
        private static final long serialVersionUID = 2014338818796000944L;

        FairSync(int permits) {
            super(permits);
        }

        protected int tryAcquireShared(int acquires) {
            for (;;) {
                // 存在前驱节点直接返回，然后将该线程加入到同步队列
                if (hasQueuedPredecessors())
                    return -1;
                int available = getState();
                int remaining = available - acquires;
                if (remaining < 0 ||
                    compareAndSetState(available, remaining))
                    return remaining;
            }
        }
    }


  NonfairSync  分析
  /**
   * NonFair version
   */
  static final class NonfairSync extends Sync {
      private static final long serialVersionUID = -2694183684443567898L;

      NonfairSync(int permits) {
          super(permits);
      }

      // 直接调用AQS的nonfairTryAcquireShared方法，判断信号量减去传入的值如果大于0 ，同时更新信号量成功，则获取信号成功，否则如果小于0，就阻塞当前线程，直到被释放
      protected int tryAcquireShared(int acquires) {
          return nonfairTryAcquireShared(acquires);
      }
  }

  总结：acquire方法先获取信号量，然后将信号量减一，如果结果小于0或者使用cas更新信号量失败，会再次获取信号量最新的值
  然后cas去更新，直到成功为止，返回后的值如果大于0，则直接放行，如果小于0，则阻塞，必须使用release方法将信号量加上1，
  然后释放同步队列首节点，首节点的线程也会继续释放下个节点，而由于信号量又被首节点的线程减一，后面的节点依然继续阻塞，
  必须再次release