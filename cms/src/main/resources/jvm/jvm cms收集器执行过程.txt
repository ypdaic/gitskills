（1）一种以获取最短回收停顿时间为目标的收集器。

（2）一般用于互联网站或者B/S系统的服务端

（3）基于标记-清除算法的实现，不过更为复杂，整个过程为4个步骤：

    A、初始标记：标记GC Root能直接引用的对象
    B、并发标记：利用多线程对每个GC Root对象进行tracing搜索，在堆中查找其下所有能关联到的对象。
    C、重新标记：为了修正并发标记期间，用户程序继续运作而导致标志产生变动的那一部分对象的标记记录。
    D、并发清除：利用多个线程对标记的对象进行清除

（4）由于耗时最长的并发标记和并发清除操作都是用户线程一起工作，所以总体来说，CMS的内存回收工作是和用户线程一起并发执行的。

（5）缺点：

    A、对CPU资源占用比较多。可能因为占用一部分CPU资源导致应用程序响应变慢。
    B、CMS无法处理浮动垃圾。在并发清除阶段，用户程序继续运行，可能产生新的内存垃圾，这一部分垃圾出现在标记过程之后，因此，CMS无法清除。这部分垃圾称为“浮动垃圾“
    C、需要预留一部分内存，在垃圾回收时，给用户程序使用。
    D、基于标记-清除算法，容易产生大量内存碎片，导致full GC（full GC进行内存碎片的整理）