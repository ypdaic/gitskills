G1 GC 有计划地避免在整个JAVA 堆中进行全区域的垃圾收集，G1 跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值）
在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region


使用G1替换CMS的情况

1：超过50%的java堆被活动的数据占用
2：对象分配频率或年代提升频率变化很大
3：GC停顿时间过长（长于0.5至1秒）


G1的亮点：G1 GC 可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程


一个对象被不同区域引用的问题
一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用
判断对象存活时，是否需要扫描整个JAVA堆才能保证准确

在其他的分代收集器，也存在这样的问题

回收新生代也不得不同时扫描老年代？
这样的话会降低Minor GC的效率

解决方法：

    无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局 扫描
    每个Region都有一个对应的Remembered Set
    每次Reference类型的数据写数据时，都会产生一个Write Barrier暂时中断操作
    然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region
    如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的
    Remembered Set中
    当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set,就可以保证不进行全局
    扫描，也不会有遗漏


G1 回收器优化建议：

    避免使用-Xmn或 -XX:NewRatio 等相关选项显示设置年轻代大小
    固定年轻代的大小会覆盖暂停时间目标

    暂停时间目标不要太过严苛


G1执行的第一阶段：初始标记(Initial Marking )

    这个阶段是STW(Stop the World )的，所有应用线程会被暂停，标记出从GC Root开始直接可达的对象。

2）G1执行的第二阶段：并发标记

    从GC Roots开始对堆中对象进行可达性分析，找出存活对象，耗时较长。当并发标记完成后，开始最终标记(Final Marking )阶段

3）最终标记

    标记那些在并发标记阶段发生变化的对象，将被回收。

4）筛选回收

    首先对各个Regin的回收价值和成本进行排序，根据用户所期待的GC停顿时间指定回收计划，回收一部分Region。

    最后，G1中提供了两种模式垃圾回收模式，Young GC和Mixed GC，两种都是Stop The World(STW)的。

