
三色标记在cms,g1回收器的并发标记中使用


黑色:根对象，或者该对象与它的子对象都被扫描过。
灰色:对本身被扫描，但是还没扫描完该对象的子对象。
白色:未被扫描对象，如果扫描完所有对象之后，最终为白色的为不可达对象，既垃圾对象。

三色标记法存在漏标问题


    某个时刻线程A已经完成标记了，全部是黑色
           线程B还未全部标记，是灰色，此时如果将线程A中的某个变量指向线程B的还未标记对象，并线程B中指向未标记变量的引用切除
           这就造成了未被标记对象的被错误回收的问题，因为此时两个线程都认为标出完成了，而未被标记的对象此时是白色的，就需要回收

    CMS 中的解决方案
    Incremental Update 算法 当一个白色对象被一个黑色对象引用，将黑色对象重新标记为灰色，让垃圾回收器重新扫描，也就是重新标记

    G1 中的解决方案
    SATB(snapshot-at-the-beginning)
    刚开始做一个快照，当 B 和 C 消失的时候要把这个引用推到 GC 的堆栈，保证 C 还能被 GC 扫描到，最重要的是要把这个引用推到 GC 的堆栈，是灰色对 象指向白色的引用，如果一旦某一个引用消失掉了，
    我会把它放到栈(GC 方法运行时数据也是来自栈中)，我其实还是能找到它的，我下回直接扫描他 就行了，那样白色就不会漏标。
    对应 G1 的垃圾回收过程中的:
    最终标记( Final Marking)
    对用户线程做另一个短暂的暂停，用于处理并发阶段结后仍遗留下来的最后那少量的 SATB 记录(漏标对象)。（G1只是标记了，等待下次GC进行清除）


    对比
    SATB 算法是关注引用的删除。(B->C 的引用)
    Incremental Update 算法关注引用的增加。(A->C 的引用)
    G1 如果使用 Incremental Update 算法，因为变成灰色的成员还要重新扫，重新再来一遍，效率太低了。 所以 G1 在处理并发标记的过程比 CMS 效率要高，这个主要是解决漏标的算法决定的。


 总结
 这里描述的是 G1 处理跨代引用的细节，其实在 CMS 中也有类似的处理方式，比如 CardTable,也需要记录一个 RSet 来记录，我们对比一下，在 G1 中是每 一个 Region 都需要一个 RSet 的内存区域，导致有 G1 的 RSet 可能会占据整个堆容量的 20%乃至更多。但是 CMS 只需要一份，所以就内存占用来说，G1
 占用的内存需求更大，虽然 G1 的优点很多，但是我们不推荐在堆空间比较小的情况下使用 G1，尤其小于 6 个 G。