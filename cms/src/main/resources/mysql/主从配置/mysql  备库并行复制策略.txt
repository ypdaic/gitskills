1：在官方的5.6版本之前，MySQL只支持单线程复制，由此在主库并发高、TPS高时就会出现严重的主备延迟问题。

2：并行复制的2个基本原则

    1：不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个worker中。

    2：同一个事务不能被拆开，必须放到同一个worker中。


3：按表并发

    如果两个事务更新不同的表，它们就可以并行。因为数据是存储在表里的，所以按表分发，可以保证两个worker不会更新同一行。
    当然，如果有跨表的事务，还是要把两张表放在一起考虑的，
    具体实现就是：
        每个worker线程对应一个hash表，用于保存当前正在这个worker的“执行队列”里的事务所涉及的表
        hash表的key是“库名.表名”，value是一个数字，表示队列中有多少个事务修改这个表。

4：按行并发

    如果两个事务没有更新相同的行，它们在备库上可以并行执行。显然，这个模式要求binlog格式必须是row。
    相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的计算资源
    事务hash表中还需要考虑唯一键，即key应该是“库名+表名+索引a的名字+a的值”

5：官方MySQL5.6版本，支持了并行复制，只是支持的粒度是按库并行

6：MariaDB的并行复制策略
    1：在一组里面一起提交的事务，有一个相同的commit_id，下一组就是commit_id+1；

    2：commit_id直接写到binlog里面；

    3：传到备库应用的时候，相同commit_id的事务分发到多个worker执行；

    4：这一组全部执行完成后，coordinator再去取下一批。

7：MySQL 5.7的并行复制策略

    由参数slave-parallel-type来控制并行复制策略

    配置为DATABASE，表示使用MySQL 5.6版本的按库并行策略；
    配置为 LOGICAL_CLOCK，表示的就是类似MariaDB的策略
    其机制如下：
        同时处于prepare状态的事务，在备库执行时是可以并行的；
        处于prepare状态的事务，与处于commit状态的事务之间，在备库执行时也是可以并行的。

        binlog_group_commit_sync_delay参数，表示延迟多少微秒后才调用fsync;
        binlog_group_commit_sync_no_delay_count参数，表示累积多少次以后才调用fsync。
        这两个参数是用于故意拉长binlog从write到fsync的时间，以此减少binlog的写盘次数。在MySQL 5.7的并行复制策略里，它们可以用来制造更多的“同时处于prepare阶段的事务”。这样就增加了备库复制的并行度。
        也就是说，这两个参数，既可以“故意”让主库提交得慢些，又可以让备库执行得快些。在MySQL 5.7处理备库延迟的时候，可以考虑调整这两个参数值，来达到提升备库复制并发度的目的。

8：MySQL 5.7.22的并行复制策略

    新增了一个参数binlog-transaction-dependency-tracking，用来控制是否启用这个新策略。这个参数的可选值有以下三种

    1：COMMIT_ORDER，表示的就是前面介绍的，根据同时进入prepare和commit来判断是否可以并行的策略。

    2：WRITESET，表示的是对于事务涉及更新的每一行，计算出这一行的hash值，组成集合writeset。如果两个事务没有操作相同的行，也就是说它们的writeset没有交集，就可以并行。
            当然为了唯一标识，这个hash值是通过“库名+表名+索引名+值”计算出来的。如果一个表上除了有主键索引外，还有其他唯一索引，那么对于每个唯一索引，insert语句对应的writeset就要多增加一个hash值。
            你可能看出来了，这跟我们前面介绍的基于MySQL 5.5版本的按行分发的策略是差不多的。不过，MySQL官方的这个实现还是有很大的优势：
            writeset是在主库生成后直接写入到binlog里面的，这样在备库执行的时候，不需要解析binlog内容（event里的行数据），节省了很多计算量；
            不需要把整个事务的binlog都扫一遍才能决定分发到哪个worker，更省内存；
            由于备库的分发策略不依赖于binlog内容，所以binlog是statement格式也是可以的。
            因此，MySQL 5.7.22的并行复制策略在通用性上还是有保证的。
            当然，对于“表上没主键”和“外键约束”的场景，WRITESET策略也是没法并行的，也会暂时退化为单线程模型。

    3：WRITESET_SESSION，是在WRITESET的基础上多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序。


同时存在slave_parallel_type=database，而binlog_transaction_dependency_tracking=commit_order，这2个参数会不会冲突呢？如果会以哪个策略为准呢？
那就是以slave_parallel_type=database为准了