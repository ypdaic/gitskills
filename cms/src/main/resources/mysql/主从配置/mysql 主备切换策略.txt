主备延迟的存在，所以在主备切换的时候，就相应的有不同的策略

    可靠性优先策略:

        在图1的双M结构下，从状态1到状态2切换的详细过程是这样的：

        1：判断备库B现在的seconds_behind_master，如果小于某个值（比如5秒）继续下一步，否则持续重试这一步；

        2：把主库A改成只读状态，即把readonly设置为true；

        3：判断备库B的seconds_behind_master的值，直到这个值变成0为止；

        4：把备库B改成可读写状态，也就是把readonly 设置为false；

        5：把业务请求切到备库B。

        这个切换流程，一般是由专门的HA系统来完成的，我们暂时称之为可靠性优先流程。

    可用性优先策略:

        如果我强行把步骤4、5调整到最开始执行，也就是说不等主备数据同步，直接把连接切到备库B，并且让备库B可以读写，那么系统几乎就没有不可用时间了。

        我们把这个切换流程，暂时称作可用性优先流程。这个切换流程的代价，就是可能出现数据不一致的情况。

        可用性优先策略，且binlog_format=mixed时的切换流程和数据结果：

            1：步骤2中，主库A执行完insert语句，插入了一行数据（4,4），之后开始进行主备切换。

            2：步骤3中，由于主备之间有5秒的延迟，所以备库B还没来得及应用“插入c=4”这个中转日志，就开始接收客户端“插入 c=5”的命令。

            3：步骤4中，备库B插入了一行数据（4,5），并且把这个binlog发给主库A。

            4：步骤5中，备库B执行“插入c=4”这个中转日志，插入了一行数据（5,4）。而直接在备库B执行的“插入c=5”这个语句，传到主库A，就插入了一行新数据（5,5）。

        可用性优先策略，但设置binlog_format=row

            1：因为row格式在记录binlog的时候，会记录新插入的行的所有字段值，所以最后只会有一行不一致。
               而且，两边的主备同步的应用线程会报错duplicate key error并停止。也就是说，这种情况下，备库B的(5,4)和主库A的(5,5)这两行数据，都不会被对方执行。


    结论：

        1：使用row格式的binlog时，数据不一致的问题更容易被发现。而使用mixed或者statement格式的binlog时，数据很可能悄悄地就不一致了。如果你过了很久才发现数据不一致的问题，很可能这时的数据不一致已经不可查，或者连带造成了更多的数据逻辑不一致。

        2：主备切换的可用性优先策略会导致数据不一致。因此，大多数情况下，我都建议你使用可靠性优先策略。毕竟对数据服务来说的话，数据的可靠性一般还是要优于可用性的。

