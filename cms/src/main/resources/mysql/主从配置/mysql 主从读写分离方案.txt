从库读取数据存在的问题：
    由于主从可能存在延迟，客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更新之前的状态。


解决方案:

    强制走主库方案；

        对于必须要拿到最新结果的请求，强制将其发到主库上。比如，在一个交易平台上，卖家发布商品以后，马上要返回主页面，看商品是否发布成功。那么，这个请求需要拿到最新的结果，就必须走主库。

        对于可以读到旧数据的请求，才将其发到从库上。在这个交易平台上，买家来逛商铺页面，就算晚几秒看到最新发布的商品，也是可以接受的。那么，这类请求就可以走从库。

    sleep方案；

        主库更新后，读从库之前先sleep一下。具体的方案就是，类似于执行一条select sleep(1)命令。

        这个方案的假设是，大多数情况下主备延迟在1秒之内，做一个sleep可以有很大概率拿到最新的数据。

    判断主备无延迟方案；

        第一种：每次从库执行查询请求前，先判断seconds_behind_master是否已经等于0。如果还不等于0 ，那就必须等到这个参数变为0才能执行查询请求。

        第二种方法，对比位点确保主备无延迟：

            Master_Log_File和Read_Master_Log_Pos，表示的是读到的主库的最新位点；
            Relay_Master_Log_File和Exec_Master_Log_Pos，表示的是备库执行的最新位点。
            如果Master_Log_File和Relay_Master_Log_File、Read_Master_Log_Pos和Exec_Master_Log_Pos这两组值完全相同，就表示接收到的日志已经同步完成。

        第三种方法，对比GTID集合确保主备无延迟：
            Auto_Position=1 ，表示这对主备关系使用了GTID协议。
            Retrieved_Gtid_Set，是备库收到的所有日志的GTID集合；
            Executed_Gtid_Set，是备库所有已经执行完成的GTID集合。
            如果这两个集合相同，也表示备库接收到的日志都已经同步完成。

            可见，对比位点和对比GTID这两种方法，都要比判断seconds_behind_master是否为0更准确。

        但是这种方法还是会存在某个事物还没有同步到从库，但是到从库上按照上述方案查询主从延时已经没有延时了，一样会存在过期读

    配合semi-sync方案；(一主一从没有问题，一主多从任然存在问题)

        semi-sync原理：

        事务提交的时候，主库把binlog发给从库；

        从库收到binlog以后，发回给主库一个ack，表示收到了；

        主库收到这个ack以后，才能给客户端返回“事务完成”的确认。

        也就是说，如果启用了semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。

        但是semi-sync只能确保一个从机完成了同步，一主多从任然存在问题

    等主库位点方案；
        命令:
        select master_pos_wait(file, pos[, timeout]);

        1：它是在从库执行的；

        2：参数file和pos指的是主库上的文件名和位置；

        3：timeout可选，设置为正整数N表示这个函数最多等待N秒。


        这个命令正常返回的结果是一个正整数M，表示从命令开始执行，到应用完file和pos表示的binlog位置，执行了多少事务。

        当然，除了正常返回一个正整数M外，这条命令还会返回一些其他结果，包括：

        如果执行期间，备库同步线程发生异常，则返回NULL；

        如果等待超过N秒，就返回-1；

        如果刚开始执行的时候，就发现已经执行过这个位置了，则返回0。

        具体过程：

            trx1事务更新完成后，马上执行show master status得到当前主库执行到的File和Position；

            选定一个从库执行查询语句；

            在从库上执行select master_pos_wait(File, Position, 1)；

            如果返回值是>=0的正整数，则在这个从库执行查询语句；

            否则，到主库执行查询语句。

    等GTID方案:

        如果你的数据库开启了GTID模式，对应的也有等待GTID的方案。

        命令：
            select wait_for_executed_gtid_set(gtid_set, 1);

        等待，直到这个库执行的事务中包含传入的gtid_set，返回0；

        超时返回1。

        在前面等位点的方案中，我们执行完事务后，还要主动去主库执行show master status。而MySQL 5.7.6版本开始，允许在执行完更新类事务后，把这个事务的GTID返回给客户端，这样等GTID的方案就可以减少一次查询。

        等GTID的执行流程就变成了：

            trx1事务更新完成后，从返回包直接获取这个事务的GTID，记为gtid1；

            选定一个从库执行查询语句；

            在从库上执行 select wait_for_executed_gtid_set(gtid1, 1)；

            如果返回值是0，则在这个从库执行查询语句；

            否则，到主库执行查询语句。

            跟等主库位点的方案一样，等待超时后是否直接到主库查询，需要业务开发同学来做限流考虑。


        怎么能够让MySQL在执行事务后，返回包中带上GTID呢：

            你只需要将参数session_track_gtids设置为OWN_GTID，然后通过API接口mysql_session_track_get_first从返回包解析出GTID的值即可

