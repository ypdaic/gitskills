1：什么是GTID

    1：简化复制和降低主从复制维护的难度，提高复制的可运维性，不再依赖Master的binlog文件名和文件中的位置。

    2：GTID的全称是Global Transaction Identifier，也就是全局事务ID，是一个事务在提交的时候生成的，是这个事务的唯一标识。它由两部分组成，格式是：

        GTID=server_uuid:gno

        server_uuid是一个实例第一次启动时自动生成的，是一个全局唯一的值；
        gno是一个整数，初始值是1，每次提交事务的时候分配给这个事务，并加1。

        查询server_uuid

        	select @@server_uuid

2：怎样开启GTID

    在线修改GTID时，必须按照如下顺序 OFF <-> OFF_PERMISSIVE <-> ON_PERMISSIVE <-> ON，不能跳过其中环节，比如 gtid_mode 从off 不能直接变为on，否则MySQL会进行提示。

3：GTID_MODE说明

    OFF            ：不产生GTID，Slave只接受不带GTID的事务
    OFF_PERMISSIVE ：不产生GTID，Slave即接受不带GTID的事务，也接受带GTID的事务
    ON_PERMISSIVE  ：产生GTID，Slave即接受不带GTID的事务，也接受带GTID的事务
    ON             ：产生GTID，Slave只能接受带GTID的事务。

4：修改GTID_MODE

    set global gtid_mode=OFF;

    set global gtid_mode=OFF_PERMISSIVE;

    set global gtid_mode=ON_PERMISSIVE;

    set global gtid_mode=ON;

    注意修改gtid_mode=ON时，要先设置enforce_gtid_consistency=ON

    每次切换GTID，都会生成新的binlog

5：GTID的生成方式

    GTID有两种生成方式，而使用哪种方式取决于session变量gtid_next的值

    1： 如果gtid_next=automatic，代表使用默认值。这时，MySQL就会把server_uuid:gno分配给这个事务。
        a. 记录binlog的时候，先记录一行 SET @@SESSION.GTID_NEXT=‘server_uuid:gno’;
        b. 把这个GTID加入本实例的GTID集合。

    2： 如果gtid_next是一个指定的GTID的值，比如通过set gtid_next='current_gtid’指定为current_gtid，那么就有两种可能：
        a. 如果current_gtid已经存在于实例的GTID集合中，接下来执行的这个事务会直接被系统忽略；
        b. 如果current_gtid没有存在于实例的GTID集合中，就将这个current_gtid分配给接下来要执行的事务，也就是说系统不需要给这个事务生成新的GTID，因此gno也不用加1。

    注意，一个current_gtid只能给一个事务使用。这个事务提交后，如果要执行下一个事务，就要执行set 命令，把gtid_next设置成另外一个gtid或者automatic。

    这样，每个MySQL实例都维护了一个GTID集合，用来对应“这个实例执行过的所有事务”。

6：在GTID模式下，备库B要设置为新主库A’的从库的语法如下：

    CHANGE MASTER TO
    MASTER_HOST=$host_name
    MASTER_PORT=$port
    MASTER_USER=$user_name
    MASTER_PASSWORD=$password
    master_auto_position=1

    master_auto_position=1就表示这个主备关系使用的是GTID协议

7： 手动指定GTID例子

    如果实例X有从库，那么将CREATE TABLE和insert语句的binlog同步过去执行的话，执行事务之前就会先执行这两个SET命令， 这样被加入从库的GTID集合的，就是图中的这两个GTID
    假设，现在这个实例X是另外一个实例Y的从库，并且此时在实例Y上执行了下面这条插入语句：
    insert into t values(1,1);
    并且，这条语句在实例Y上的GTID是 “aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”。
    那么，实例X作为Y的从库，就要同步这个事务过来执行，显然会出现主键冲突，导致实例X的同步线程停止。这时，我们应该怎么处理呢？

    set gtid_next='aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10';
    begin;
    commit;
    set gtid_next=automatic;
    start slave;

    其中，前三条语句的作用，是通过提交一个空事务，把这个GTID加到实例X的GTID集合中。如图5所示，就是执行完这个空事务之后的show master status的结果。

    这样，我再执行start slave命令让同步线程执行起来的时候，虽然实例X上还是会继续执行实例Y传过来的事务，但是由于“aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”已经存在于实例X的GTID集合中了，所以实例X就会直接跳过这个事务，也就不会再出现主键冲突的错误。

    在上面的这个语句序列中，start slave命令之前还有一句set gtid_next=automatic。这句话的作用是“恢复GTID的默认分配行为”，也就是说如果之后有新的事务再执行，就还是按照原来的分配方式，继续分配gno=3。

8：参考
    http://blog.itpub.net/22664653/viewspace-2133818