因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。

    这，就是MRR优化的设计思路。此时，语句的执行流程变成了这样：

    根据索引a，定位到满足条件的记录，将id值放入read_rnd_buffer中;

    将read_rnd_buffer中的id进行递增排序；

    排序后的id数组，依次到主键id索引中查记录，并作为结果返回。

    这里，read_rnd_buffer的大小是由read_rnd_buffer_size参数控制的

另外需要说明的是，如果你想要稳定地使用MRR优化的话，需要设置set optimizer_switch="mrr_cost_based=off"。（官方文档的说法，是现在的优化器策略，判断消耗的时候，会更倾向于不使用MRR，把mrr_cost_based设置为off，就是固定使用MRR了。）

MRR能够提升性能的核心在于，这条查询语句在索引a上做的是一个范围查询（也就是说，这是一个多值查询），可以得到足够多的主键id。这样通过排序以后，再去主键索引查数据，才能体现出“顺序性”的优势。