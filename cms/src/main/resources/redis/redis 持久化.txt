redis 持久化有两种方式，RDB，AOF，RDB是在某个时间点将内存数据保存到磁盘，AOF是将我们的操作命令以日志方式保存到磁盘，记录的就是RESP协议

RDB配置：

save 900 1 #在900s内如果有1条数据被写入，则产生一次快照。
save 300 10 #在300s内如果有10条数据被写入，则产生一次快照
save 60 10000 #在60s内如果有10000条数据被写入，则产生一次快照
stop-writes-on-bgsave-error yes
#stop-writes-on-bgsave-error ：
如果为yes则表示，当备份进程出错的时候，
主进程就停止进行接受新的写入操作，这样是为了保护持久化的数据一致性的问题。

①RDB 的创建与载入

SAVE：阻塞 Redis 的服务器进程，直到 RDB 文件被创建完毕。SAVE 命令很少被使用，因为其会阻塞主线程来保证快照的写入，
由于 Redis 是使用一个主线程来接收所有客户端请求，这样会阻塞所有客户端请求。

BGSAVE：该指令会 Fork 出一个子进程来创建 RDB 文件，不阻塞服务器进程，子进程接收请求并创建 RDB 快照，父进程继续接收客户端的请求。

子进程在完成文件的创建时会向父进程发送信号，父进程在接收客户端请求的过程中，在一定的时间间隔通过轮询来接收子进程的信号。

我们也可以通过使用 lastsave 指令来查看 BGSAVE 是否执行成功，lastsave 可以返回最后一次执行成功 BGSAVE 的时间。

②自动化触发 RDB 持久化的方式
    自动化触发RDB持久化的方式如下：
        根据 redis.conf 配置里的 SAVE m n 定时触发（实际上使用的是 BGSAVE）。
        主从复制时，主节点自动触发。
        执行 Debug Reload。
        执行 Shutdown 且没有开启 AOF 持久化。

RDB 持久化方式的缺点如下：
内存数据全量同步，数据量大的状况下，会由于 I/O 而严重影响性能。
可能会因为 Redis 宕机而丢失从当前至最近一次快照期间的数据。

AOF 持久化：保存写状态
    AOF 持久化是通过保存 Redis 的写状态来记录数据库的。
    相对 RDB 来说，RDB 持久化是通过备份数据库的状态来记录数据库，而 AOF 持久化是备份数据库接收到的指令：
    AOF 记录除了查询以外的所有变更数据库状态的指令。
    以增量的形式追加保存到 AOF 文件中

AOF 配置：
    ①打开 redis.conf 配置文件，将 appendonly 属性改为 yes。

    ②修改 appendfsync 属性，该属性可以接收三种参数，分别是 always，everysec，no。

    always 表示总是即时将缓冲区内容写入 AOF 文件当中，everysec 表示每隔一秒将缓冲区内容写入 AOF 文件，no 表示将写入文件操作交由操作系统决定。
    一般来说，操作系统考虑效率问题，会等待缓冲区被填满再将缓冲区数据写入 AOF 文件中。


日志重写解决 AOF 文件不断增大

    随着写操作的不断增加，AOF 文件会越来越大。假设递增一个计数器 100 次，如果使用 RDB 持久化方式，我们只要保存最终结果 100 即可。

    而 AOF 持久化方式需要记录下这 100 次递增操作的指令，而事实上要恢复这条记录，只需要执行一条命令就行，所以那一百条命令实际可以精简为一条。

    Redis 支持这样的功能，在不中断前台服务的情况下，可以重写 AOF 文件，同样使用到了 COW（写时拷贝）。

    重写过程如下：
    调用 fork()，创建一个子进程。
    子进程把新的 AOF 写到一个临时文件里，不依赖原来的 AOF 文件。
    主进程持续将新的变动同时写到内存和原来的 AOF 里。
    主进程获取子进程重写 AOF 的完成信号，往新 AOF 同步增量变动。
    使用新的 AOF 文件替换掉旧的 AOF 文件。

AOF 和 RDB 的优缺点如下：
    RDB 优点：全量数据快照，文件小，恢复快。
    RDB 缺点：无法保存最近一次快照之后的数据。
    AOF 优点：可读性高，适合保存增量数据，数据不易丢失。
    AOF 缺点：文件体积大，恢复时间长。

