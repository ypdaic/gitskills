1: 消息在发往rabbitmq的过程中丢失

   解决方案：使用rabbitmq提供的事物功能，但是使用事物后会降低系统的吞吐量，因为太耗性能，一般我们用发送者确认机制
            如果消息发送到了exchange，就会返回ack，如果消息在rabbitmq内部异常了，就会返回nack，然后我们可以考虑
            将消息重新发一次，或者我们的消息在发送给mq之前提前在数据库，redis中保存一份，设置状态为发送中，接受到ack后
            设置状态为发送成功，然后使用定时任务重新发送状态为发送中的消息

2: 消息发送到rabbitmq后，mq自己挂掉了

   解决方案：开启exchange，queue，message 三者的持久化
            还是存在mq在持久化之前就挂掉了，但是这种几率很小
            RabbitMQ 并不是为每条消息都做 fsync 的处理，可能仅仅保存到 cache 中而不是物理磁盘上，
            在这段时间内 RabbitMQ broker 发生 crash, 消息保存到 cache 但是还没来得及落盘，那么这些消息将会丢失。

            消息什么时候刷到磁盘？

                写入文件前会有一个 Buffer, 大小为 1M, 数据在写入文件时，首先会写入到这个 Buffer，如果 Buffer 已满，则会将 Buffer 写入到文件（未必刷到磁盘）。
                有个固定的刷盘时间：25ms, 也就是不管 Buffer 满不满，每隔 25ms，Buffer 里的数据及未刷新到磁盘的文件内容必定会刷到磁盘。
                每次消息写入后，如果没有后续写入请求，则会直接将已写入的消息刷到磁盘：使用 Erlang 的 receive x after 0 实现，只要进程的信箱里没有消息，则产生一个 timeout 消息，而 timeout 会触发刷盘操作。


3: 消费端自己丢消息

    场景: 消费端在拿到消费后，还没进行业务处理就挂掉了，如果此时是自动ack的，那么这个消息就丢失了

    解决方案：使用手动ack，如果在业务在ack之前就挂了，broker会将消息发给其他的消费者进行消费，可能存在重复消费问题
             因为可能是在业务处理之后，ack之前挂了