MessageListenerContainer的创建工厂，提供两个实现

SimpleRabbitListenerContainerFactory

DirectRabbitListenerContainerFactory

AbstractRabbitListenerContainerFactory 属性如下：



    // 由AbstractRabbitListenerContainerFactoryConfigurer注入，configure方法，101行

    private ConnectionFactory connectionFactory;



    // 这里为null,AbstractRabbitListenerContainer  中默认为ConditionalRejectingErrorHandler
    // 在listener消费异常后，并且抛出的RuntimeException 异常才会被errorHandler处理
    // 该ErrorHandler 在 RabbitListenerErrorHandler 的后面执行

	private ErrorHandler errorHandler;



    // 由AbstractRabbitListenerContainerFactoryConfigurer注入，
    // configure方法，103行，如果有提供MessageConverter的实现
    // AbstractRabbitListenerContainerFactory默认不提供，可以由我们自己提供覆盖下面的默认值
    // 由于通过注解方式的Listener是MessagingMessageListenerAdapter 其默认的是 SimpleMessageConverter

	private MessageConverter messageConverter;



    // 由RabbitProperties提供，消费者应答模式
    // NONE 创建消费者时rabbit客户端自动应答
    // MANUAL 业务手动应答
    // AUTO spring 进行应答
    // AbstractRabbitListenerContainer 该属性默认为AUTO
	private AcknowledgeMode acknowledgeMode;



    // 默认为false, 当存在transactionManager 会被强求设为true
    // transactionManager 需要我们外部手动指定
    // true表示创建的channel 支持事物
	private Boolean channelTransacted;



    // 默认为null，必须我们外部手动指定
    // AbstractRabbitListenerContainer 默认用的是SimpleAsyncTaskExecutor

	private Executor taskExecutor;



    // 事物管理器默认为空，需要我们外部手动指定

	private PlatformTransactionManager transactionManager;



    // qos 批量获取的消息数,由RabbitProperties提供
    // DirectRabbitListenerContainerFactory 的messagesPerAck 如果大于
    // RabbitProperties的则会覆盖，但是DirectRabbitListenerContainerFactory 的messagesPerAck必须手动指定
    // SimpleRabbitListenerContainerFactory 的txSize 如果大于RabbitProperties的则会覆盖，由RabbitProperties提供
    // 为SimpleRabbitListenerContainerFactory 且AcknowledgeMode为MANUAL或AUTO 才有效
    // 为DirectRabbitListenerContainerFactory 都有效，不区分ack模式
    // 默认值250
	private Integer prefetchCount;



    // 默认情况下是否重新入队被拒绝的消息，由RabbitProperties提供
    // AbstractRabbitListenerContainer 该值为true
    // 如果为true,这会重新投递这些消息到队列继续消费
    // 只有AcknowledgeMode为AUTO时，才会生效，AUTO时，ack，nack 都是spring给我们做，而不需要业务自己处理
	private Boolean defaultRequeueRejected;



    // 由RabbitProperties提供,用于后续在MessageListenerContainer中使用
    // 重试策略拦截器，分有状态和无状态
    // StatelessRetryInterceptorBuilder 无状态重试拦截器建造者
    // StatefulRetryInterceptorBuilder 有状态重试拦截器建造者
    // RetryOperationsInterceptor 无状态拦截器
    // StatefulRetryOperationsInterceptor 有状态拦截器

    // 而且该拦截器只能配置一个，当存在拦截器时，
    // AbstractMessageListenerContainer 的 ContainerDelegate proxy = this.delegate;
    // 属性 会创建一个代理对象
    // 也就是添加重试机制
	private Advice[] adviceChain;



    // 暂时没有手动指定，默认是FixedBackOff，固定速率的AsyncMessageProcessingConsumer initialize方法失败重试
    // DirectMessageListenerContainer startConsumers方法 启动消费者失败重试间隔
	private BackOff recoveryBackOff;


    // 由RabbitProperties提供
    // SimpleContainer 默认为true
    // missingQueuesFatal 默认为false
    // 如果不指定的话 AbstractMessageListenerContainer 在执行initialize方法时会去
    // 从 bean 名称为spring.amqp.global.properties 的Properties中去获取

    // 其作用就是，在容器创建消费者之前，先判断队列是否已经被创建了，如果有
    // 队列没有被创建，就抛异常出来
	private Boolean missingQueuesFatal;


    // AbstractMessageListenerContainer 默认为true
    // 为true 时表示容器调用start 方法启动时，会去获取amqpadmin, 并调用amqpadmin的initialize
    // 进行队列，交换器的提前创建
    // 如果为false, 且   AbstractMessageListenerContainer 的autoDeclare 属性为true 时，
    // 一样会进行队列，交换器的创建
	private Boolean mismatchedQueuesFatal;


    // 默认为null，创建消费者的消费标签策略
	private ConsumerTagStrategy consumerTagStrategy;


    // 空闲容器事件应多久发布一次。由RabbitProperties提供
    // 只对DirectMessageListenerContainer 有用
    // 用于 创建定时任务，以监控消费者创建失败后，或者取消后，重新创建消费者
	private Long idleEventInterval;


    // 默认5000
    // SimpleMessageListenerContainer 用于检测 队列是否创建完成的间隔，默认检测3次
    // DirectMessageListenerContainer 用于检测消费者连接通道关闭后，消费者重启间隔
	private Long failedDeclarationRetryInterval;


    // 创建bean时注入
	private ApplicationEventPublisher applicationEventPublisher;


    // 创建bean时注入
	private ApplicationContext applicationContext;


    // 容器是否自动启动 由AbstractRabbitListenerContainerFactoryConfigurer注入，configure方法，105行，始终为true
    // 如果@RabbitListener设置了则会覆盖上面的值
	private Boolean autoStartup;


    // spring SmartLifecycle 的启动顺序
	private Integer phase;


    // 收到消息后置处理器
    // 在执行业务代码之前执行
    // 支持排序 需要继承PriorityOrdered， Ordered 接口
	private MessagePostProcessor[] afterReceivePostProcessors;


    // 业务代码之后，存在返回值时，消息发送前的处理器
    // 不支持排序，需要自己添加进来就排好序
	private MessagePostProcessor[] beforeSendReplyPostProcessors;


    // 重试模板
	private RetryTemplate retryTemplate;


    // 重试用尽时调用，配合retryTemplate使用
	private RecoveryCallback<?> recoveryCallback;


    // 外部提供的用于配置MessageListenerContainer
    // 需要我们手动指定，比如指定transactionManager
	private Consumer<C> containerConfigurer;




SimpleRabbitListenerContainerFactory属性如下：

    // 当ack模式为自动时，一次确认的消息数，当为预取模式时，预取值小于该值时增大到该值
	private Integer txSize;

    // 消费者最小数 由RabbitProperties提供
    private Integer concurrentConsumers;

    // 消费者最大数 由RabbitProperties提供
    private Integer maxConcurrentConsumers;

    // 消费者需要增加时启动的最小间隔，默认 10s
    // 连续consecutiveActiveTrigger次收到消息就增加消费者
    private Long startConsumerMinInterval;

    // 消费者需要减少时的间隔值，默认 60s
    // 连续consecutiveIdleTrigger次收不到消息就减少消费者
    private Long stopConsumerMinInterval;

    // 消费者的连续接收数
    // 必须手动指定，默认值10
    private Integer consecutiveActiveTrigger;

    // 消费者连续收不到消息数
    // 必须手动指定，默认值 10
    private Integer consecutiveIdleTrigger;

    // 消息接收超时时间
    // 从BlockingQueueConsumer 的队列中获取消息的超时时间，默认 1s
    private Long receiveTimeout;

    // 使用BatchingTemplate 发送消息时，要置为true
    private Boolean deBatchingEnabled;

DirectRabbitListenerContainerFactory

    // 监控连接断开的消费者，并重新启动新消费者
    private TaskScheduler taskScheduler;


    // 设置运行任务的频率，以检查失败的使用者和空闲容器。默认值为10000，但会向下调整
       *最小 为 idleEventInterval / 2
    private Long monitorInterval;



    // 每个队列消费者的数量
    private Integer consumersPerQueue = 1;


    // 设置确认之前收到的消息数（成功）。
    private Integer messagesPerAck;


    // 两次ack 的时间间隔，超过后就要进行批量ack
    private Long ackTimeout;