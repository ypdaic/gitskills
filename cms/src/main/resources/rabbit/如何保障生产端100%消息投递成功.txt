rabbit有confirm机制，
confirm机制原理：
    消息生产者把消息发送给MQ，如果接收成功，MQ会返回一个ack消息给生产者
    如果消息接收不成功，MQ会返回一个nack消息给生产者

有一个问题就是，rabbit并不是每接收一条消息都持久化到磁盘，而是等有几千条消息的时候，会一次性刷新到磁盘，所以confirm机制其实是一个异步监听机制，就是为了保证系统的高
吞吐量，有了confirm还是不能100%保证消息不丢失，存在消息还没有刷新到磁盘就宕机的情况。那怎么办？

解决方案：消息提前持久化+定时任务

具体流程：1：生成者再投递消息之前，先把消息持久化到redis或DB，建议redis，高性能。消息状态为发送中
         2：confirm机制监听消息是否发送成功？如果ack成功消息，删除redis中的消息
         3：如果nack不成功的消息，这个可以根据自身业务选择是否重发此消息。也可以删除此消息，由业务自身决定
         4：这边加个定时任务，来拉取隔一定时间，如果消息状态还是发送中，这个状态就表明，生成者没有收到ack成功消息
         5：定时任务会作补偿性的投递消息。这个时候如果MQ回调ack成功接收了，再把redis中此消息删除

上面的机制就是一种补偿机制，我不管MQ有没有真正接收到消息，只要我的redis中的消息状态也是发送中，就表示此消息没哟正确成功投递。再次启动定时任务去监控，发起补偿投递
当然定时任务我们可以加上一个补偿的次数，如果大于3次，还是没有收到ack消息，那就直接把消息的状态设置为失败

不过这样的方案，可能会发送多次相同的消息，很有可能MQ已经接收了消息，就是ack消息回调时出现网络故障，没有让生产者收到，那就需要要求消费者一定在消费的时候保障幂等性