首先通过确定领导选举算法，QuorumPeer.createElectionAlgorithm()
该方法第一步就是创建一个QuorumCnxManager，并创建一个Listener线程，该线程主要接受集群其他节点的链接
第二步：创建一个FastLeaderElection，FastLeaderElection会创建一个Message，用于处理存储其他节点发送消息，和给其他节点发送消息

接着开始具体的选举过程，即QuorumPeer的run方法，初始化时，服务器的状态LOOKING，
然后调用FastLeaderElection.lookForLeader()方法开始向其他服务器和本机发送本机的myid,zxid,currentEpoch，也就是往sendqueue添加我们要发送的消息
接着开始从recvqueue中获取消息，最开始获取就是本机发送给本机的

投票就是比较先比较界号，如果相等就比较zxid,如果zxid相等就比较myi，比较后，其他节点比本机节点高，就更新本机的leaderid，zxid，peerEpoch为其他节点的，并向其他节点发送
新的leaderid，zxid，peerEpoch信息，包括本机


在向其他节点发送本机的投票信息时，只会往myid小于本机的服务器发送。发送消息就是先发送本机myid，然后使用SendWorker将投票信息发给其他节点，使用RecvWorker接受其他节点返回的投票
信息


接受方先接受到myid，然后对比myid，如果myid比自己的小，直接关闭连接，重新
开启一个连接，连接比自己小的，如果大于自己的myid,这使用SendWorker往回发送本机的投票信息，使用RecvWorker接受其他节点投票信息

比如有myid为0，1，2的服务器，

第一轮：
myid:0先投一票给自己，然后接受myid:1的消息，投一票给myid:1，比较大小后，发现myid:1 大，更新myid:0的推举leader为myid:1，再次向其他节点发送投票通知，并存储myid:1 的投票信息，开始pk,由于myid:1 只有一票还不能选举成功

myid:1先投一票给自己，然后接受myid:0的投票，发现myid:0 小则不用向其他节点发送投票通知，并存储myid:0 的投票信息，开始pk 由于myid:1 只有一票还不能选举成功

第二轮：
myid:0 接收到自己发送的myid:1 的投票信息，此时本地的票选已为myid:1 不用再次向其他节点发送投票通常，并存储myid:1 的投票信息，开始pk,由于myid:1 有2票 超过半数选举成功，myid:0 为follower
myid:1 接收到myid:0 发送的myid:1 的投票信息 ，此时本地的票选已为myid:1 不用再次向其他节点发送投票通常，并存储myid:1 的投票信息，开始pk,由于myid:1 有2票 超过半数选举成功，myid:1 为leader


完成选举后，leader会在Leader.lead() 方法中死循环发送ping消息 ，follow一样，如果发现从Leader获取ping消息失败，就会触发重新选举






https://www.cnblogs.com/crazylqy/p/7132133.html


https://www.cnblogs.com/fanguangdexiaoyuer/p/10311228.html