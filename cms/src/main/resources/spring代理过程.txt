在springboot应用中，我们在某个services类中使用了事务@Transactional，缓存@Cacheable，异步@Async等注解时
前提是开启了相关功能，否则这个注解都是无效的

实际上这个services类最终在spring容器中是一个被代理的类，要么是通过jdk动态代理，要么是
通过cglib进行代理。该代理始终要实现Advised接口

开启异步功能后，在执行异步的后置处理器时，如果当前bean已经被代理了，就将异步的advisor放在拦截链的最上面

开启定时任务，是使用的代理去执行目标类的方法，那么拦截链都会生效

判断某个bean是否要生成代理，先获取bean及其所有父接口，父类上的所有方法，然后每个方法去匹配每个advisor中的Pointcut接口的实现类
在这个实现类中使用具体的规则扫描每个方法，是否符合其规则，符合就生成代理，并且将符合的advisor放到代理中

对于事务来说，默认只会去匹配public方法，具体在AbstractFallbackTransactionAttributeSource的153行
对于缓存来说，默认只会去匹配public方法，具体在AbstractFallbackCacheOperationSource的128行

生成的代理最终通过JDK动态代理，或者cglib生成
代理在执行方法时，先去找到对应的advised，然后通过advised找到advisor集合，在通过advisor去匹配方法，将匹配的advisor中的advice
拦截链放到一个集合中。然后将这个拦截链返回，如果拦截链不为空则递归调用拦截链，最终调到业务bean上，如果拦截链为空，则直接调用
业务bean

在代理模式下，如果要在业务中暴露代理，就需要使用@EnableAspectJAutoProxy注解，并将exposeProxy属性
置为true

@EnableAspectJAutoProxy，@EnableTransactionManagement同时启用的话，最终生效的是@EnableAspectJAutoProxy
给的AnnotationAwareAspectJAutoProxyCreator，该类会创建BeanFactoryAspectJAdvisorsBuilderAdapter为使用了
使用了@After，@Before注解的方法创建advisor，这个优先级在AopConfigUtils的静态块中写死了
