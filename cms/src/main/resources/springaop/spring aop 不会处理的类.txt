    AnnotationAwareAspectJAutoProxyCreator

    @Override
	protected boolean isInfrastructureClass(Class<?> beanClass) {
		// Previously we setProxyTargetClass(true) in the constructor, but that has too
		// broad an impact. Instead we now override isInfrastructureClass to avoid proxying
		// aspects. I'm not entirely happy with that as there is no good reason not
		// to advise aspects, except that it causes advice invocation to go through a
		// proxy, and if the aspect implements e.g the Ordered interface it will be
		// proxied by that interface and fail at runtime as the advice method is not
		// defined on the interface. We could potentially relax the restriction about
		// not advising aspects in the future.
		// 没有
		return (super.isInfrastructureClass(beanClass) ||
				(this.aspectJAdvisorFactory != null && this.aspectJAdvisorFactory.isAspect(beanClass)));
	}

    // 如下几种类型都不会走代理
	protected boolean isInfrastructureClass(Class<?> beanClass) {
    		boolean retVal = Advice.class.isAssignableFrom(beanClass) ||
    				Pointcut.class.isAssignableFrom(beanClass) ||
    				Advisor.class.isAssignableFrom(beanClass) ||
    				AopInfrastructureBean.class.isAssignableFrom(beanClass);
    		if (retVal && logger.isTraceEnabled()) {
    			logger.trace("Did not attempt to auto-proxy infrastructure class [" + beanClass.getName() + "]");
    		}
    		return retVal;
    	}

    	aspectJAdvisorFactory 的isAspect方法
        @Override
    	public boolean isAspect(Class<?> clazz) {
    		return (hasAspectAnnotation(clazz) && !compiledByAjc(clazz));
    	}


        // 包含@Aspect注解的不会走代理
    	private boolean hasAspectAnnotation(Class<?> clazz) {
    		return (AnnotationUtils.findAnnotation(clazz, Aspect.class) != null);
    	}

    	/**
    	 * We need to detect this as "code-style" AspectJ aspects should not be
    	 * interpreted by Spring AOP.
    	 */
        // 属性已"ajc$"开头的不会走代理
    	private boolean compiledByAjc(Class<?> clazz) {
    		// The AJTypeSystem goes to great lengths to provide a uniform appearance between code-style and
    		// annotation-style aspects. Therefore there is no 'clean' way to tell them apart. Here we rely on
    		// an implementation detail of the AspectJ compiler.
    		for (Field field : clazz.getDeclaredFields()) {
    			if (field.getName().startsWith(AJC_MAGIC)) {
    				return true;
    			}
    		}
    		return false;
    	}