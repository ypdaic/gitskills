使用 @EnableFeignClients 注解开启feign功能，下面就看@EnableFeignClients 做了什么

    使用Import注解导入了FeignClientsRegistrar
    @Import(FeignClientsRegistrar.class)

    FeignClientsRegistrar的作用就是查找应用的Configuration类的注解上是否有@EnableFeignClients注解，如果有就获取
    basePackageClasses,basePackages,clients的信息，也就是我们使用了@FeignClient注解 类的包路径，然后解析每个类，
    获取@FeignClient的注解信息，然后通过这些信息，创建一个FeignClientFactoryBean的BeanDefinitionHolder注入到spring容器中，后续
    自动注入的Feign 接口实现都是通过FeignClientFactoryBean创建的

    关键代码：
        private void registerFeignClient(BeanDefinitionRegistry registry,
        			AnnotationMetadata annotationMetadata, Map<String, Object> attributes) {
            String className = annotationMetadata.getClassName();
            BeanDefinitionBuilder definition = BeanDefinitionBuilder
                    .genericBeanDefinition(FeignClientFactoryBean.class);
            validate(attributes);
            definition.addPropertyValue("url", getUrl(attributes));
            definition.addPropertyValue("path", getPath(attributes));
            String name = getName(attributes);
            definition.addPropertyValue("name", name);
            String contextId = getContextId(attributes);
            definition.addPropertyValue("contextId", contextId);
            definition.addPropertyValue("type", className);
            definition.addPropertyValue("decode404", attributes.get("decode404"));
            definition.addPropertyValue("fallback", attributes.get("fallback"));
            definition.addPropertyValue("fallbackFactory", attributes.get("fallbackFactory"));
            definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);

            String alias = contextId + "FeignClient";
            AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();

            boolean primary = (Boolean) attributes.get("primary"); // has a default, won't be
                                                                    // null

            beanDefinition.setPrimary(primary);

            String qualifier = getQualifier(attributes);
            if (StringUtils.hasText(qualifier)) {
                alias = qualifier;
            }

            BeanDefinitionHolder holder = new BeanDefinitionHolder(beanDefinition, className,
                    new String[] { alias });
            BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);
        }



    FeignClientFactoryBean创建代理的过程：

        由于FeignClientFactoryBean实现了FactoryBean，我们就从getObject入手

        @Override
        public Object getObject() throws Exception {
            return getTarget();
        }

        /**
         * @param <T> the target type of the Feign client
         * @return a {@link Feign} client created with the specified data and the context
         * information
         */
        <T> T getTarget() {
            // 获取FeignContext，会提供一个默认的配置类FeignClientsConfiguration，是FeignContext构造器中默认指定的
            // FeignClientsConfiguration提供了编解码器，Builder等等，Builder 包含我们的配置参数
            FeignContext context = this.applicationContext.getBean(FeignContext.class);
            // FeignContext会根据FeignClientFactoryBean的contextId创建一个子容器，也就是为每个服务创建一个独立的子容器，子容器会去加载FeignClientsConfiguration，和@FeignClient注解配置的自定义配置类
            // 这里是获取builder对象，这里的builder对象已经封装完成的builder
            Feign.Builder builder = feign(context);

            if (!StringUtils.hasText(this.url)) {
                if (!this.name.startsWith("http")) {
                    this.url = "http://" + this.name;
                }
                else {
                    this.url = this.name;
                }
                this.url += cleanPath();
                // 获取代理类的关键，使用jdk动态代理创建
                return (T) loadBalance(builder, context,
                        new HardCodedTarget<>(this.type, this.name, this.url));
            }
            if (StringUtils.hasText(this.url) && !this.url.startsWith("http")) {
                this.url = "http://" + this.url;
            }
            String url = this.url + cleanPath();
            Client client = getOptional(context, Client.class);
            if (client != null) {
                if (client instanceof LoadBalancerFeignClient) {
                    // not load balancing because we have a url,
                    // but ribbon is on the classpath, so unwrap
                    client = ((LoadBalancerFeignClient) client).getDelegate();
                }
                builder.client(client);
            }
            Targeter targeter = get(context, Targeter.class);
            // 获取代理类的关键，使用jdk动态代理创建
            return (T) targeter.target(this, builder, context,
                    new HardCodedTarget<>(this.type, this.name, url));
        }

        protected Feign.Builder feign(FeignContext context) {
        		FeignLoggerFactory loggerFactory = get(context, FeignLoggerFactory.class);
        		Logger logger = loggerFactory.create(this.type);

        		// @formatter:off
        		// 获取Builder对象，如果开启hystrix，就是HystrixFeign.Builder，如果使用了sentinel，就是SentinelFeign.Builder，默认就是Feign.Builder
        		// 其实HystrixFeign.Builder，SentinelFeign.Builder 就是提供了自己的InvocationHandlerFactory，默认就是InvocationHandlerFactory.Default();
        		// InvocationHandlerFactory其实就是用来创建代理对象的InvocationHandler
        		Feign.Builder builder = get(context, Feign.Builder.class)
        				// required values
        				// 获取配置的logger实现
        				.logger(logger)
        				// 获取配置的Encoder实现，发送请求对RequestTemplate的body设置请求的体，同时也会设置RequestTemplate的header，默认是SpringEncoder
        				.encoder(get(context, Encoder.class))
        				// 获取配置的Decoder实现，对响应进行转码，默认是SpringDecoder
        				.decoder(get(context, Decoder.class))
        				// 获取配置的Contract，对方法的参数进行解析，默认是SpringMvcContract
        				.contract(get(context, Contract.class));
        		// @formatter:on

        		configureFeign(context, builder);

        		return builder;
        }

        // 提供通过配置参数feign.client  为每个服务指定自己的Encoder，Decoder，Contract，errorDecoder，RequestInterceptor，Retryer，ErrorDecoder，一般也不在这里进行配置
        // 一般配置在自定义的配置文件中
        protected void configureFeign(FeignContext context, Feign.Builder builder) {
        		FeignClientProperties properties = this.applicationContext
        				.getBean(FeignClientProperties.class);
        		if (properties != null) {
        			if (properties.isDefaultToProperties()) {
        				configureUsingConfiguration(context, builder);
        				configureUsingProperties(
        						properties.getConfig().get(properties.getDefaultConfig()),
        						builder);
        				configureUsingProperties(properties.getConfig().get(this.contextId),
        						builder);
        			}
        			else {
        				configureUsingProperties(
        						properties.getConfig().get(properties.getDefaultConfig()),
        						builder);
        				configureUsingProperties(properties.getConfig().get(this.contextId),
        						builder);
        				configureUsingConfiguration(context, builder);
        			}
        		}
        		else {
        			configureUsingConfiguration(context, builder);
        		}
        	}


        protected <T> T loadBalance(Feign.Builder builder, FeignContext context,
        			HardCodedTarget<T> target) {
        	    // 获取Client实现，默认就是LoadBalancerFeignClient，带负载均衡能力
        		Client client = getOptional(context, Client.class);
        		if (client != null) {
        			builder.client(client);
        			// 获取Targeter实现，默认DefaultTargeter，开启hystrix，就是HystrixTargeter，而外加了设置获取fallback，fallbackFactory，SetterFactory（可以自定义自己的command参数，默认已服务名为groupId，接口
        			// 接口方法名为commandkey，其他全是默认值）
        			Targeter targeter = get(context, Targeter.class);
        			// 真正创建代理的地方，都会走到Feign的build方法
        			return targeter.target(this, builder, context, target);
        		}

        		throw new IllegalStateException(
        				"No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-netflix-ribbon?");
        	}


         public Feign build() {
              SynchronousMethodHandler.Factory synchronousMethodHandlerFactory =
                  new SynchronousMethodHandler.Factory(client, retryer, requestInterceptors, logger,
                      logLevel, decode404, closeAfterDecode, propagationPolicy);
              ParseHandlersByName handlersByName =
                  new ParseHandlersByName(contract, options, encoder, decoder, queryMapEncoder,
                      errorDecoder, synchronousMethodHandlerFactory);
              // 由ReflectiveFeign创建代理类，invocationHandlerFactory就是feign真正执行方法调用的地方
              return new ReflectiveFeign(handlersByName, invocationHandlerFactory, queryMapEncoder);
            }




    FeignContext 会为每个@FeignClient注解都创建一个子AplicationContext