1：
    如果@Adaptive 被使用在某个具体的实现类上的话，那么该实例类就是某个扩展点接口的适配器实例类
    我们配置具体使用的是那个实例类由这个适配器类去加载

2：
    @Adaptive 被使用在扩展点接口的方法上，表示接口实现类没有提供适配的功能，需要代码去生成一个代理的适配类，如果又没有提供适配类，又没有在
    方法上加这个注解则生成的代理适配类所有方法都是抛异常的


public @interface Adaptive {
    /**
     * Decide which target extension to be injected. The name of the target extension is decided by the parameter passed
     * in the URL, and the parameter names are given by this method.
     * <p>
     * If the specified parameters are not found from {@link URL}, then the default extension will be used for
     * dependency injection (specified in its interface's {@link SPI}).
     * <p>
     * For examples, given <code>String[] {"key1", "key2"}</code>:
     * <ol>
     * <li>find parameter 'key1' in URL, use its value as the extension's name</li>
     * <li>try 'key2' for extension's name if 'key1' is not found (or its value is empty) in URL</li>
     * <li>use default extension if 'key2' doesn't appear either</li>
     * <li>otherwise, throw {@link IllegalStateException}</li>
     * </ol>
     * If default extension's name is not give on interface's {@link SPI}, then a name is generated from interface's
     * class name with the rule: divide classname from capital char into several parts, and separate the parts with
     * dot '.', for example: for {@code org.apache.dubbo.xxx.YyyInvokerWrapper}, its default name is
     * <code>String[] {"yyy.invoker.wrapper"}</code>. This name will be used to search for parameter from URL.
     * 用于设置从url获取值的key，默认值是接口名
     * @return parameter key names in URL
     */
    String[] value() default {};

}